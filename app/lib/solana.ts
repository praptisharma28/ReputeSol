import { Connection, PublicKey, Keypair } from '@solana/web3.js';
import { Program, AnchorProvider, Wallet } from '@coral-xyz/anchor';
import fs from 'fs';
import path from 'path';

/**
 * Solana RPC Connection
 * This is how we talk to the Solana blockchain
 */
export function getConnection(): Connection {
  const rpcUrl = process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 'https://api.devnet.solana.com';
  return new Connection(rpcUrl, 'confirmed');
}

/**
 * Load the authority keypair from file
 * This wallet can call update_score instruction
 */
export function getAuthorityKeypair(): Keypair {
  const keypairPath = process.env.AUTHORITY_KEYPAIR_PATH || '../reputesol-authority.json';
  const fullPath = path.resolve(process.cwd(), keypairPath);

  const keypairData = JSON.parse(fs.readFileSync(fullPath, 'utf-8'));
  return Keypair.fromSecretKey(new Uint8Array(keypairData));
}

/**
 * Get Anchor Program instance
 * This gives us typed methods to call our smart contract
 */
export async function getProgram() {
  const connection = getConnection();
  const authority = getAuthorityKeypair();

  // Create provider (Anchor needs this to sign transactions)
  const wallet = new Wallet(authority);
  const provider = new AnchorProvider(connection, wallet, {
    commitment: 'confirmed',
  });

  // Load program
  const programId = new PublicKey(process.env.NEXT_PUBLIC_PROGRAM_ID!);

  // Load IDL (Interface Description - generated by Anchor)
  const idlPath = path.resolve(
    process.cwd(),
    '../reputesol-program/target/idl/reputesol_program.json'
  );
  const idl = JSON.parse(fs.readFileSync(idlPath, 'utf-8'));

  const program = new Program(idl, programId, provider);
  return { program, provider, authority };
}

/**
 * Find user's PDA (Program Derived Address)
 * This is deterministic - same wallet always gets same PDA
 *
 * Seeds: [b"user", owner_pubkey]
 */
export function getUserPDA(wallet: PublicKey): [PublicKey, number] {
  const programId = new PublicKey(process.env.NEXT_PUBLIC_PROGRAM_ID!);
  return PublicKey.findProgramAddressSync(
    [Buffer.from('user'), wallet.toBuffer()],
    programId
  );
}

/**
 * Check if user account exists on-chain
 */
export async function userAccountExists(wallet: PublicKey): Promise<boolean> {
  const connection = getConnection();
  const [userPDA] = getUserPDA(wallet);

  const accountInfo = await connection.getAccountInfo(userPDA);
  return accountInfo !== null;
}
