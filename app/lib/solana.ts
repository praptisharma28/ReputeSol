import { Connection, PublicKey, Keypair } from '@solana/web3.js';
import { Program, AnchorProvider } from '@coral-xyz/anchor';
import fs from 'fs';
import path from 'path';

// Simple Wallet implementation for Anchor Provider
class NodeWallet {
  constructor(readonly payer: Keypair) {}

  async signTransaction(tx: any) {
    tx.partialSign(this.payer);
    return tx;
  }

  async signAllTransactions(txs: any[]) {
    return txs.map((tx) => {
      tx.partialSign(this.payer);
      return tx;
    });
  }

  get publicKey() {
    return this.payer.publicKey;
  }
}

/**
 * Solana RPC Connection
 * This is how we talk to the Solana blockchain
 */
export function getConnection(): Connection {
  const rpcUrl = process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 'https://api.devnet.solana.com';
  return new Connection(rpcUrl, 'confirmed');
}

/**
 * Load the authority keypair from file
 * This wallet can call update_score instruction
 */
export function getAuthorityKeypair(): Keypair {
  const keypairPath = process.env.AUTHORITY_KEYPAIR_PATH || '../reputesol-authority.json';
  const fullPath = path.resolve(process.cwd(), keypairPath);

  const keypairData = JSON.parse(fs.readFileSync(fullPath, 'utf-8'));
  return Keypair.fromSecretKey(new Uint8Array(keypairData));
}

/**
 * Get Anchor Program instance
 * This gives us typed methods to call our smart contract
 */
export async function getProgram() {
  const connection = getConnection();
  const authority = getAuthorityKeypair();

  // Create provider (Anchor needs this to sign transactions)
  const wallet = new NodeWallet(authority);
  const provider = new AnchorProvider(connection, wallet as any, {
    commitment: 'confirmed',
  });

  // Load program
  const programId = new PublicKey(process.env.NEXT_PUBLIC_PROGRAM_ID!);

  // Load IDL (Interface Description - generated by Anchor)
  const idlPath = path.resolve(
    process.cwd(),
    '../reputesol-program/target/idl/reputesol_program.json'
  );
  const idl = JSON.parse(fs.readFileSync(idlPath, 'utf-8'));

  // Set the program ID in the IDL
  idl.address = programId.toString();

  const program = new Program(idl, provider);
  return { program, provider, authority };
}

/**
 * Find user's PDA (Program Derived Address)
 * This is deterministic - same wallet always gets same PDA
 *
 * Seeds: [b"user", owner_pubkey]
 */
export function getUserPDA(wallet: PublicKey): [PublicKey, number] {
  const programId = new PublicKey(process.env.NEXT_PUBLIC_PROGRAM_ID!);
  return PublicKey.findProgramAddressSync(
    [Buffer.from('user'), wallet.toBuffer()],
    programId
  );
}

/**
 * Check if user account exists on-chain
 */
export async function userAccountExists(wallet: PublicKey): Promise<boolean> {
  const connection = getConnection();
  const [userPDA] = getUserPDA(wallet);

  const accountInfo = await connection.getAccountInfo(userPDA);
  return accountInfo !== null;
}
