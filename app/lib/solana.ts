import { Connection, PublicKey, Keypair } from '@solana/web3.js';
import { Program, AnchorProvider } from '@coral-xyz/anchor';
import fs from 'fs';
import path from 'path';

// Simple Wallet implementation for Anchor Provider
class NodeWallet {
  constructor(readonly payer: Keypair) {}

  async signTransaction(tx: any) {
    tx.partialSign(this.payer);
    return tx;
  }

  async signAllTransactions(txs: any[]) {
    return txs.map((tx) => {
      tx.partialSign(this.payer);
      return tx;
    });
  }

  get publicKey() {
    return this.payer.publicKey;
  }
}

/**
 * Solana RPC Connection
 * This is how we talk to the Solana blockchain
 */
export function getConnection(): Connection {
  const rpcUrl = process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 'https://api.devnet.solana.com';
  return new Connection(rpcUrl, 'confirmed');
}

/**
 * Load the authority keypair from environment variable or file
 * This wallet can call update_score instruction
 */
export function getAuthorityKeypair(): Keypair {
  // First, try to load from environment variable (for Vercel/production)
  if (process.env.AUTHORITY_KEYPAIR_BASE64) {
    try {
      // Decode from base64
      const keypairString = process.env.AUTHORITY_KEYPAIR_BASE64.trim();
      const decoded = Buffer.from(keypairString, 'base64').toString('utf-8');
      const keypairData = JSON.parse(decoded);
      return Keypair.fromSecretKey(new Uint8Array(keypairData));
    } catch (error) {
      console.error('[Solana] Error parsing AUTHORITY_KEYPAIR_BASE64 from env:', error);
      throw new Error(`Failed to parse AUTHORITY_KEYPAIR_BASE64: ${error}`);
    }
  }

  if (process.env.AUTHORITY_KEYPAIR) {
    try {
      // Trim any whitespace
      const keypairString = process.env.AUTHORITY_KEYPAIR.trim();
      const keypairData = JSON.parse(keypairString);
      return Keypair.fromSecretKey(new Uint8Array(keypairData));
    } catch (error) {
      console.error('[Solana] Error parsing AUTHORITY_KEYPAIR from env:', error);
      throw new Error(`Failed to parse AUTHORITY_KEYPAIR: ${error}`);
    }
  }

  // Fall back to file (for local development)
  const keypairPath = process.env.AUTHORITY_KEYPAIR_PATH || '../reputesol-authority.json';
  const fullPath = path.resolve(process.cwd(), keypairPath);

  const keypairData = JSON.parse(fs.readFileSync(fullPath, 'utf-8'));
  return Keypair.fromSecretKey(new Uint8Array(keypairData));
}

/**
 * Get Anchor Program instance
 * This gives us typed methods to call our smart contract
 */
export async function getProgram() {
  const connection = getConnection();
  const authority = getAuthorityKeypair();

  // Create provider (Anchor needs this to sign transactions)
  const wallet = new NodeWallet(authority);
  const provider = new AnchorProvider(connection, wallet as any, {
    commitment: 'confirmed',
  });

  // Load program
  const programId = new PublicKey(process.env.NEXT_PUBLIC_PROGRAM_ID!);

  // Load IDL (Interface Description - generated by Anchor)
  // Try loading from local lib directory first (for production), then fall back to parent directory
  let idl;
  try {
    const localIdlPath = path.resolve(process.cwd(), 'lib/reputesol_program.json');
    idl = JSON.parse(fs.readFileSync(localIdlPath, 'utf-8'));
  } catch {
    const idlPath = path.resolve(
      process.cwd(),
      '../reputesol-program/target/idl/reputesol_program.json'
    );
    idl = JSON.parse(fs.readFileSync(idlPath, 'utf-8'));
  }

  // Set the program ID in the IDL
  idl.address = programId.toString();

  const program = new Program(idl, provider);
  return { program, provider, authority };
}

/**
 * Find user's PDA (Program Derived Address)
 * This is deterministic - same wallet always gets same PDA
 *
 * Seeds: [b"user", owner_pubkey]
 */
export function getUserPDA(wallet: PublicKey): [PublicKey, number] {
  const programId = new PublicKey(process.env.NEXT_PUBLIC_PROGRAM_ID!);
  return PublicKey.findProgramAddressSync(
    [Buffer.from('user'), wallet.toBuffer()],
    programId
  );
}

/**
 * Check if user account exists on-chain
 */
export async function userAccountExists(wallet: PublicKey): Promise<boolean> {
  const connection = getConnection();
  const [userPDA] = getUserPDA(wallet);

  const accountInfo = await connection.getAccountInfo(userPDA);
  return accountInfo !== null;
}
